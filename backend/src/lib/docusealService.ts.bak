import axios from 'axios';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

interface DocuSealConfig {
  baseUrl: string;
  apiUrl: string;
  apiToken: string;
}

interface SubmitterField {
  name: string;
  default_value: string;
  readonly?: boolean;
}

interface SubmitterData {
  name: string;
  email: string;
  role: string;
  fields?: SubmitterField[];
  completed?: boolean;
}

interface CreateSubmissionRequest {
  template_id: string;
  send_email?: boolean;
  submitters: SubmitterData[];
  completed_redirect_url?: string;
  expired_redirect_url?: string;
}

interface DocuSealSubmission {
  id: string;
  template_id: string;
  status: string;
  created_at: string;
  submitters: Array<{
    id: number;
    submission_id: number;
    uuid: string;
    email: string;
    slug: string;
    name: string;
    phone: string;
    status: string;
    role: string;
    sent_at: string | null;
    opened_at: string | null;
    completed_at: string | null;
    declined_at: string | null;
    created_at: string;
    updated_at: string;
    metadata: Record<string, any>;
    preferences: Record<string, any>;
    sign_url?: string;
    embed_src?: string;
  }>;
}

class DocuSealService {
  private config: DocuSealConfig;
  private axiosInstance;

  /**
   * Convert numbers to Malaysian words (Bahasa Malaysia) including cents
   */
  private convertToMalaysianWords(num: number): string {
    if (num === 0) return 'KOSONG';
    
    const ones = ['', 'SATU', 'DUA', 'TIGA', 'EMPAT', 'LIMA', 'ENAM', 'TUJUH', 'LAPAN', 'SEMBILAN'];
    const teens = ['SEPULUH', 'SEBELAS', 'DUA BELAS', 'TIGA BELAS', 'EMPAT BELAS', 'LIMA BELAS', 'ENAM BELAS', 'TUJUH BELAS', 'LAPAN BELAS', 'SEMBILAN BELAS'];
    const tens = ['', '', 'DUA PULUH', 'TIGA PULUH', 'EMPAT PULUH', 'LIMA PULUH', 'ENAM PULUH', 'TUJUH PULUH', 'LAPAN PULUH', 'SEMBILAN PULUH'];
    
    // Split into ringgit and sen
    const ringgit = Math.floor(num);
    const sen = Math.round((num - ringgit) * 100);
    
    let result = '';
    
    // Convert ringgit part
    if (ringgit > 0) {
      result += this.convertWholeNumber(ringgit, ones, teens, tens);
      result += ' RINGGIT';
    }
    
    // Convert sen part only if there are actual cents (not 00)
    if (sen > 0 && sen < 100) {
      if (ringgit > 0) result += ' ';
      result += this.convertWholeNumber(sen, ones, teens, tens);
      result += ' SEN';
    }
    
    return result || 'KOSONG';
  }

  private convertWholeNumber(num: number, ones: string[], teens: string[], tens: string[]): string {
    if (num === 0) return '';
    if (num < 10) return ones[num];
    if (num < 20) return teens[num - 10];
    if (num < 100) {
      const ten = Math.floor(num / 10);
      const one = num % 10;
      return tens[ten] + (one ? ' ' + ones[one] : '');
    }
    if (num < 1000) {
      const hundred = Math.floor(num / 100);
      const remainder = num % 100;
      let result = (hundred === 1 ? 'SERATUS' : ones[hundred] + ' RATUS');
      if (remainder) result += ' ' + this.convertWholeNumber(remainder, ones, teens, tens);
      return result;
    }
    if (num < 1000000) {
      const thousand = Math.floor(num / 1000);
      const remainder = num % 1000;
      let result = (thousand === 1 ? 'SERIBU' : this.convertWholeNumber(thousand, ones, teens, tens) + ' RIBU');
      if (remainder) result += ' ' + this.convertWholeNumber(remainder, ones, teens, tens);
      return result;
    }
    
    // For larger numbers, use simplified approach
    return num.toLocaleString('en-MY').replace(/,/g, ' ');
  }

  constructor() {
    this.config = {
      baseUrl: process.env.DOCUSEAL_BASE_URL || 'http://localhost:3001', // For user-facing URLs
      apiUrl: process.env.DOCUSEAL_API_URL || process.env.DOCUSEAL_BASE_URL || 'http://host.docker.internal:3001', // For backend API calls
      apiToken: process.env.DOCUSEAL_API_TOKEN || ''
    };

    console.log('DocuSeal Service Config:', {
      baseUrl: this.config.baseUrl,
      hasApiToken: !!this.config.apiToken,
      envBaseUrl: process.env.DOCUSEAL_BASE_URL,
      envApiToken: process.env.DOCUSEAL_API_TOKEN ? 'SET' : 'NOT_SET'
    });

    // Temporarily allow development without real API token
    if (!this.config.apiToken && process.env.NODE_ENV === 'production') {
      throw new Error('DOCUSEAL_API_TOKEN environment variable is required');
    }

    this.axiosInstance = axios.create({
      baseURL: this.config.apiUrl,
      headers: {
        'Content-Type': 'application/json',
        'X-Auth-Token': this.config.apiToken
      },
      timeout: 30000
    });
  }

  /**
   * Create a new document submission with pre-filled data
   */
  async createSubmission(request: CreateSubmissionRequest): Promise<DocuSealSubmission> {
    try {
      console.log('Creating DocuSeal submission:', {
        template_id: request.template_id,
        submitters_count: request.submitters.length,
        company_fields: request.submitters.find(s => s.role === 'Company')?.fields,
        company_signature_field: request.submitters.find(s => s.role === 'Company')?.fields?.find(f => f.name === 'company_signature'),
        company_stamp_field: request.submitters.find(s => s.role === 'Company')?.fields?.find(f => f.name === 'company_stamp')
      });

      const response = await this.axiosInstance.post('/api/submissions', request);
      
      console.log('DocuSeal submission created successfully:', response.data.id);
      return response.data;
    } catch (error) {
      console.error('Failed to create DocuSeal submission:', error);
      
      if (axios.isAxiosError(error)) {
        throw new Error(`DocuSeal API error: ${error.response?.data?.message || error.message}`);
      }
      
      throw error;
    }
  }

  /**
   * Get submission status
   */
  async getSubmission(submissionId: string): Promise<DocuSealSubmission> {
    try {
      const response = await this.axiosInstance.get(`/api/submissions/${submissionId}`);
      return response.data;
    } catch (error) {
      console.error('Failed to get DocuSeal submission:', error);
      
      if (axios.isAxiosError(error)) {
        throw new Error(`DocuSeal API error: ${error.response?.data?.message || error.message}`);
      }
      
      throw error;
    }
  }

  /**
   * Get all templates
   */
  async getTemplates(): Promise<Array<{ id: string; name: string; created_at: string }>> {
    try {
      const response = await this.axiosInstance.get('/api/templates');
      return response.data;
    } catch (error) {
      console.error('Failed to get DocuSeal templates:', error);
      
      if (axios.isAxiosError(error)) {
        throw new Error(`DocuSeal API error: ${error.response?.data?.message || error.message}`);
      }
      
      throw error;
    }
  }

  /**
   * Create loan agreement signing request for applications (before loan record exists)
   */
  async createApplicationAgreementSigning(applicationId: string, applicationData: any): Promise<{
    submission: DocuSealSubmission;
    signUrl: string;
  }> {
    try {
      if (!applicationData.user?.email) {
        throw new Error(`Borrower email not found for application: ${applicationId}`);
      }

      // Pre-fill fields according to DocuSeal API format
      const companyFields: SubmitterField[] = [
        {
          name: 'first_payment_date',
          default_value: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toLocaleDateString('en-MY').toUpperCase(),
          readonly: true
        },
        {
          name: 'payment_day',
          default_value: '1HB',
          readonly: true
        },
        {
          name: 'loan_term',
          default_value: `${applicationData.term}`,
          readonly: true
        },
        {
          name: 'company_details',
          default_value: 'OPG CAPITAL HOLDINGS SDN. BHD.\nNO. PENDAFTARAN:  (1443435-P)\nNO. LESEN: WL3337/07/01-9/02022\n31-10-11, THE CEO, LEBUH NIPAH 5, \n11950, BAYAN LEPAS, PENANG, MALAYSIA',
          readonly: true
        },
        {
          name: 'borrower_details',
          default_value: `${(applicationData.user.fullName || 'N/A').toUpperCase()}\nIC NO: ${applicationData.user.icNumber || 'N/A'}\nADDRESS: ${`${applicationData.user.address1 || ''} ${applicationData.user.address2 || ''} ${applicationData.user.city || ''} ${applicationData.user.state || ''}`.trim().toUpperCase() || 'N/A'}`,
          readonly: true
        },
        {
          name: 'principal_text',
          default_value: `${this.convertToMalaysianWords(applicationData.principalAmount)}`,
          readonly: true
        },
        {
          name: 'principal_number',
          default_value: `RM ${applicationData.principalAmount.toLocaleString('en-MY')}`,
          readonly: true
        },
        {
          name: 'interest_text',
          default_value: `${this.convertToMalaysianWords(applicationData.interestRate * 12)}`,
          readonly: true
        },
        {
          name: 'interest_number',
          default_value: `${(applicationData.interestRate * 12).toFixed(2)}`,
          readonly: true
        },
        {
          name: 'monthly_installment',
          default_value: `${this.convertToMalaysianWords(Math.round(applicationData.monthlyPayment * 100) / 100)} SAHAJA (RM ${applicationData.monthlyPayment.toLocaleString('en-MY', { minimumFractionDigits: 2, maximumFractionDigits: 2 })})`,
          readonly: true
        },
        {
          name: 'total_loan',
          default_value: `${this.convertToMalaysianWords(Math.round((applicationData.principalAmount * (1 + applicationData.interestRate / 100 * applicationData.term / 12)) * 100) / 100)} SAHAJA (RM ${(applicationData.principalAmount * (1 + applicationData.interestRate / 100 * applicationData.term / 12)).toLocaleString('en-MY', { minimumFractionDigits: 2, maximumFractionDigits: 2 })})`,
          readonly: true
        },
        {
          name: 'agreement_date',
          default_value: new Date().toLocaleDateString('en-MY').toUpperCase(),
          readonly: true
        },
        {
          name: 'company_name',
          default_value: 'OPG CAPITAL HOLDINGS SDN. BHD.',
          readonly: true
        },
        {
          name: 'company_registration',
          default_value: '202101043135',
          readonly: true
        }
      ];

      // Add signature and stamp fields if URLs are available
      if (process.env.COMPANY_SIGNATURE_IMAGE_URL) {
        companyFields.push({
          name: 'company_signature',
          default_value: process.env.COMPANY_SIGNATURE_IMAGE_URL,
          readonly: true
        });
      }

      if (process.env.COMPANY_STAMP_IMAGE_URL) {
        companyFields.push({
          name: 'company_stamp',
          default_value: process.env.COMPANY_STAMP_IMAGE_URL,
          readonly: true
        });
      }

      // Create submission with all three parties
      const submission = await this.createSubmission({
        template_id: process.env.DOCUSEAL_LOAN_AGREEMENT_TEMPLATE_ID || '',
        send_email: true,
        submitters: [
          {
            name: 'Kredit.my Sdn Bhd',
            email: process.env.COMPANY_SIGNING_EMAIL || 'admin@kredit.my',
            role: 'Company',
            fields: companyFields, // Company gets pre-filled data
            completed: true // Automatically mark company as signed
          },
          {
            name: applicationData.user.fullName || 'Borrower',
            email: applicationData.user.email,
            role: 'Borrower'
            // No fields array - borrower signs but doesn't need pre-filled data
          },
          {
            name: process.env.WITNESS_NAME || 'Legal Representative',
            email: process.env.WITNESS_EMAIL || 'legal@kredit.my',
            role: 'Witness'
            // No fields array - witness signs but doesn't need pre-filled data
          }
        ],
        completed_redirect_url: `${process.env.FRONTEND_URL}/dashboard/loans?tab=applications&signed=success`,
        expired_redirect_url: `${process.env.FRONTEND_URL}/dashboard/loans?tab=applications&signed=expired`
      });

      // Store submission ID in the loan record for tracking (if loan exists)
      // For applications, we track it via the audit trail metadata
      const application = await prisma.loanApplication.findUnique({
        where: { id: applicationId },
        include: { loan: true }
      });

      // Extract submission ID properly - DocuSeal API returns array of submitters
      const submitters = Array.isArray(submission) ? submission : submission.submitters;
      const submissionId = Array.isArray(submission) 
        ? (submission.length > 0 ? submission[0].submission_id : null)
        : submission.id;

      if (application?.loan && submissionId) {
        await prisma.loan.update({
          where: { id: application.loan.id },
          data: {
            docusealSubmissionId: submissionId.toString(),
            agreementStatus: 'PENDING_SIGNATURE'
          }
        });
      }

      console.log(`Application agreement signing initiated for application ${applicationId}, submission ${submissionId}`);
      console.log('DocuSeal submission response:', JSON.stringify(submission, null, 2));
      
      console.log('Submitters array:', submitters);
      console.log('Submitters length:', submitters?.length);
      
      const borrowerSubmitter = submitters?.find(s => {
        console.log('Checking submitter:', { role: s.role, email: s.email });
        return s.role === 'Borrower';
      });
      
      // Use embed_src (preferred) or sign_url, or construct from slug
      let signUrl = '';
      if (borrowerSubmitter) {
        signUrl = borrowerSubmitter.embed_src || borrowerSubmitter.sign_url || `${this.config.baseUrl}/s/${borrowerSubmitter.slug}`;
      }
      
      if (!borrowerSubmitter || !signUrl) {
        console.error('No borrower submitter found or no signing URL available');
        console.error('Available submitters:', submitters?.map(s => ({ role: s.role, email: s.email, slug: s.slug })) || 'No submitters found');
        // Don't throw error, continue with default URL
        signUrl = `${this.config.baseUrl}/submissions/${submissionId || 'unknown'}`;
      }
      
      console.log('Borrower signing URL:', signUrl);

      // Add audit trail entry for signing initiation
      await prisma.loanApplicationHistory.create({
        data: {
          applicationId: applicationId,
          previousStatus: applicationData.status,
          newStatus: 'PENDING_SIGNATURE',
          changedBy: 'SYSTEM_DOCUSEAL',
          changeReason: 'Digital signing process initiated',
          notes: `Loan agreement sent for digital signing. DocuSeal Submission ID: ${submissionId || 'pending'}`,
          metadata: {
            docusealSubmissionId: submissionId ? submissionId.toString() : null,
            initiatedAt: new Date().toISOString(),
            borrowerEmail: applicationData.user.email,
            signingUrl: signUrl
          }
        }
      });
      
      return {
        submission: Array.isArray(submission) ? { 
          id: submissionId ? submissionId.toString() : '', 
          template_id: '', 
          status: 'pending', 
          created_at: new Date().toISOString(), 
          submitters: submission 
        } : submission,
        signUrl
      };

    } catch (error) {
      console.error(`Failed to create application agreement signing for application ${applicationId}:`, error);
      throw error;
    }
  }

  /**
   * Create loan agreement signing request
   */
  async createLoanAgreementSigning(loanId: string): Promise<{
    submission: DocuSealSubmission;
    signUrl: string;
  }> {
    try {
      // Get loan and borrower data from database
      const loan = await prisma.loan.findUnique({
        where: { id: loanId },
        include: {
          user: true,
          repayments: {
            orderBy: { dueDate: 'asc' }
          }
        }
      });

      if (!loan) {
        throw new Error(`Loan not found: ${loanId}`);
      }

      if (!loan.user.email) {
        throw new Error(`Borrower email not found for loan: ${loanId}`);
      }





      // Create submission
      const submission = await this.createSubmission({
        template_id: process.env.DOCUSEAL_LOAN_AGREEMENT_TEMPLATE_ID || '',
        send_email: true,
        submitters: [{
          name: loan.user.fullName || 'Borrower',
          email: loan.user.email,
          role: 'Borrower'
        }],
        completed_redirect_url: `${process.env.FRONTEND_URL}/dashboard/loans/${loanId}?signed=success`,
        expired_redirect_url: `${process.env.FRONTEND_URL}/dashboard/loans/${loanId}?signed=expired`
      });

      // Store submission ID in database for tracking
      await prisma.loan.update({
        where: { id: loanId },
        data: {
          docusealSubmissionId: submission.id,
          agreementStatus: 'PENDING_SIGNATURE'
        }
      });

      console.log(`Loan agreement signing initiated for loan ${loanId}, submission ${submission.id}`);

      return {
        submission,
        signUrl: submission.submitters[0]?.sign_url || ''
      };

    } catch (error) {
      console.error(`Failed to create loan agreement signing for loan ${loanId}:`, error);
      
      // Update loan status to reflect error
      await prisma.loan.update({
        where: { id: loanId },
        data: {
          agreementStatus: 'SIGNATURE_FAILED'
        }
      }).catch(dbError => {
        console.error('Failed to update loan status after DocuSeal error:', dbError);
      });

      throw error;
    }
  }

  /**
   * Handle DocuSeal webhook events
   */
  async handleWebhook(payload: any): Promise<void> {
    try {
      const { event_type, data } = payload;
      
      console.log('Received DocuSeal webhook:', event_type, data.id);

      switch (event_type) {
        case 'submission.completed':
          await this.handleSubmissionCompleted(data);
          break;
        case 'form.completed':
          // Handle form.completed the same as submission.completed
          console.log('Processing form.completed as submission.completed for:', data.id);
          await this.handleSubmissionCompleted(data);
          break;
        case 'submission.expired':
          await this.handleSubmissionExpired(data);
          break;
        case 'submission.declined':
          await this.handleSubmissionDeclined(data);
          break;
        default:
          console.log('Unhandled webhook event type:', event_type);
      }
    } catch (error) {
      console.error('Failed to handle DocuSeal webhook:', error);
      throw error;
    }
  }

  private async handleSubmissionCompleted(submissionData: any): Promise<void> {
    try {
      // Convert submission ID to string to match database schema
      const submissionId = String(submissionData.id || submissionData.submission_id);
      
      // First try to find loan by submission ID
      const loan = await prisma.loan.findFirst({
        where: { docusealSubmissionId: submissionId },
        include: { application: true }
      });

      if (loan) {
        // Use transaction to ensure both loan and application status are updated together
        await prisma.$transaction(async (tx) => {
          // Update loan status to PENDING_DISBURSEMENT after signing
          await tx.loan.update({
            where: { id: loan.id },
            data: {
              agreementStatus: 'SIGNED',
              agreementSignedAt: new Date(),
              status: 'PENDING_DISBURSEMENT' // Move to pending disbursement after signing
            }
          });

          // Update loan application status to PENDING_DISBURSEMENT
          await tx.loanApplication.update({
            where: { id: loan.applicationId },
            data: {
              status: 'PENDING_DISBURSEMENT'
            }
          });

          // Add audit trail entry for loan application status change
          await tx.loanApplicationHistory.create({
            data: {
              applicationId: loan.applicationId,
              previousStatus: loan.application.status,
              newStatus: 'PENDING_DISBURSEMENT',
              changedBy: 'SYSTEM_DOCUSEAL',
              changeReason: 'Document signing completed via DocuSeal, ready for disbursement',
              notes: `Loan agreement digitally signed. DocuSeal Submission ID: ${submissionId}. Status updated to PENDING_DISBURSEMENT.`,
              metadata: {
                docusealSubmissionId: submissionId,
                signedAt: new Date().toISOString(),
                submissionData: submissionData,
                loanId: loan.id
              }
            }
          });
        });

        console.log(`Loan agreement completed for loan ${loan.id}, status updated to PENDING_DISBURSEMENT with audit trail`);
      } else {
        // If no loan found, try to find application by submission ID in history
        const applicationHistory = await prisma.loanApplicationHistory.findFirst({
          where: {
                      metadata: {
            path: ['docusealSubmissionId'],
            equals: submissionId
          }
          },
          include: { application: { include: { loan: true } } }
        });

        if (applicationHistory && applicationHistory.application) {
          // Use transaction to ensure both application and loan status are updated together
          await prisma.$transaction(async (tx) => {
            // Update application status to PENDING_DISBURSEMENT
            await tx.loanApplication.update({
              where: { id: applicationHistory.applicationId },
              data: {
                status: 'PENDING_DISBURSEMENT'
              }
            });

            // If loan exists, update its status too
            if (applicationHistory.application.loan) {
              await tx.loan.update({
                where: { id: applicationHistory.application.loan.id },
                data: {
                  agreementStatus: 'SIGNED',
                  agreementSignedAt: new Date(),
                  status: 'PENDING_DISBURSEMENT'
                }
              });
            }

            // Add audit trail entry for application signing completion
            await tx.loanApplicationHistory.create({
              data: {
                applicationId: applicationHistory.applicationId,
                previousStatus: 'PENDING_SIGNATURE',
                newStatus: 'PENDING_DISBURSEMENT',
                changedBy: 'SYSTEM_DOCUSEAL',
                changeReason: 'Document signing completed via DocuSeal, ready for disbursement',
                notes: `Loan agreement digitally signed. DocuSeal Submission ID: ${submissionId}. Status updated to PENDING_DISBURSEMENT.`,
                metadata: {
                  docusealSubmissionId: submissionId,
                  signedAt: new Date().toISOString(),
                  submissionData: submissionData,
                  loanId: applicationHistory.application.loan?.id || null
                }
              }
            });
          });

          console.log(`Application agreement completed for application ${applicationHistory.applicationId}, status updated to PENDING_DISBURSEMENT with audit trail`);
        } else {
          console.error('No loan or application found for completed submission:', submissionId);
        }
      }

      // TODO: Trigger any post-signing workflows
      // - Send confirmation email
      // - Notify admin for disbursement
      // - Update frontend to show signing completion
      
    } catch (error) {
      console.error('Failed to handle submission completed:', error);
      throw error;
    }
  }

  private async handleSubmissionExpired(submissionData: any): Promise<void> {
    try {
      // Convert submission ID to string to match database schema
      const submissionId = String(submissionData.id || submissionData.submission_id);
      
      const loan = await prisma.loan.findFirst({
        where: { docusealSubmissionId: submissionId },
        include: { application: true }
      });

      if (loan) {
        await prisma.loan.update({
          where: { id: loan.id },
          data: {
            agreementStatus: 'SIGNATURE_EXPIRED'
          }
        });

        // Add audit trail entry
        await prisma.loanApplicationHistory.create({
          data: {
            applicationId: loan.applicationId,
            previousStatus: loan.application.status,
            newStatus: 'AGREEMENT_EXPIRED',
            changedBy: 'SYSTEM_DOCUSEAL',
            changeReason: 'Document signing link expired',
            notes: `Loan agreement signing expired. DocuSeal Submission ID: ${submissionId}`,
            metadata: {
              docusealSubmissionId: submissionId,
              expiredAt: new Date().toISOString(),
              submissionData: submissionData
            }
          }
        });

        console.log(`Loan agreement expired for loan ${loan.id} with audit trail`);
      }
    } catch (error) {
      console.error('Failed to handle submission expired:', error);
    }
  }

  private async handleSubmissionDeclined(submissionData: any): Promise<void> {
    try {
      // Convert submission ID to string to match database schema
      const submissionId = String(submissionData.id || submissionData.submission_id);
      
      const loan = await prisma.loan.findFirst({
        where: { docusealSubmissionId: submissionId },
        include: { application: true }
      });

      if (loan) {
        await prisma.loan.update({
          where: { id: loan.id },
          data: {
            agreementStatus: 'SIGNATURE_DECLINED'
          }
        });

        // Add audit trail entry
        await prisma.loanApplicationHistory.create({
          data: {
            applicationId: loan.applicationId,
            previousStatus: loan.application.status,
            newStatus: 'AGREEMENT_DECLINED',
            changedBy: 'SYSTEM_DOCUSEAL',
            changeReason: 'Document signing declined by borrower',
            notes: `Loan agreement signing declined. DocuSeal Submission ID: ${submissionId}`,
            metadata: {
              docusealSubmissionId: submissionId,
              declinedAt: new Date().toISOString(),
              submissionData: submissionData
            }
          }
        });

        console.log(`Loan agreement declined for loan ${loan.id} with audit trail`);
      }
    } catch (error) {
      console.error('Failed to handle submission declined:', error);
    }
  }

  /**
   * Configure webhook endpoint for DocuSeal to send events
   */
  async configureWebhook(webhookUrl: string): Promise<any> {
    try {
      console.log(`Configuring DocuSeal webhook URL: ${webhookUrl}`);
      
      const response = await axios.post(
        `${this.config.apiUrl}/webhooks`,
        {
          url: webhookUrl,
          events: ['submission.completed', 'submission.expired', 'submission.declined']
        },
        {
          headers: {
            'Authorization': `Bearer ${this.config.apiToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      console.log(`Webhook configured successfully:`, response.data);
      return response.data;

    } catch (error) {
      console.error(`Failed to configure webhook:`, error);
      if (axios.isAxiosError(error)) {
        console.error('Response:', error.response?.data);
      }
      throw new Error(`Failed to configure webhook: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get existing webhook configurations
   */
  async getWebhooks(): Promise<any> {
    try {
      console.log(`Getting DocuSeal webhook configurations`);
      
      const response = await axios.get(
        `${this.config.apiUrl}/webhooks`,
        {
          headers: {
            'Authorization': `Bearer ${this.config.apiToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      console.log(`Webhook configurations:`, response.data);
      return response.data;

    } catch (error) {
      console.error(`Failed to get webhooks:`, error);
      if (axios.isAxiosError(error)) {
        console.error('Response:', error.response?.data);
      }
      throw new Error(`Failed to get webhooks: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Download signed document PDF from DocuSeal
   */
  async downloadSignedDocument(submissionId: string): Promise<Buffer> {
    try {
      console.log(`Downloading signed document for submission: ${submissionId}`);
      
      const response = await axios.get(
        `${this.config.apiUrl}/submissions/${submissionId}/download`,
        {
          headers: {
            'Authorization': `Bearer ${this.config.apiToken}`,
            'Content-Type': 'application/json'
          },
          responseType: 'arraybuffer' // Important for binary data
        }
      );

      if (response.status !== 200) {
        throw new Error(`DocuSeal API returned status ${response.status}`);
      }

      console.log(`Successfully downloaded document for submission ${submissionId}, size: ${response.data.length} bytes`);
      return Buffer.from(response.data);

    } catch (error) {
      console.error(`Failed to download signed document for submission ${submissionId}:`, error);
      throw new Error(`Failed to download signed document: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

export const docusealService = new DocuSealService();
