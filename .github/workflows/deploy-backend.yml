name: Deploy Backend to AWS ECS

on:
  push:
    branches: [main]
    paths: 
      - 'backend/**'
      - 'client.json'
  workflow_dispatch:
    inputs:
      run_migrations:
        description: 'Force run database migrations'
        required: false
        default: 'auto'
        type: choice
        options:
          - 'auto'
          - 'true'
          - 'false'
      run_seed:
        description: 'Run database seed after deployment'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
  workflow_call:
    inputs:
      run_migrations:
        description: 'Force run database migrations'
        required: false
        default: 'auto'
        type: string
      run_seed:
        description: 'Run database seed after deployment'
        required: false
        default: 'false'
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch last 2 commits for change detection
        
      - name: Load client config
        id: config
        run: |
          echo "CLIENT=$(jq -r '.client_slug' client.json)" >> $GITHUB_OUTPUT
          echo "REGION=$(jq -r '.aws.region' client.json)" >> $GITHUB_OUTPUT
          echo "ACCOUNT=$(jq -r '.aws.account_id' client.json)" >> $GITHUB_OUTPUT
          echo "ECR_REPO=$(jq -r '.ecr.backend' client.json)" >> $GITHUB_OUTPUT
          echo "CLUSTER=$(jq -r '.ecs.cluster' client.json)" >> $GITHUB_OUTPUT
          echo "SERVICE=$(jq -r '.ecs.backend_service' client.json)" >> $GITHUB_OUTPUT
          echo "SECRETS_PREFIX=$(jq -r '.secrets_prefix' client.json)" >> $GITHUB_OUTPUT

      - name: Detect migration changes
        id: migration_check
        run: |
          # Check if prisma migrations folder has changes
          if git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^backend/prisma/migrations/'; then
            echo "migrations_changed=true" >> $GITHUB_OUTPUT
            echo "üóÑÔ∏è Database migrations detected in this commit"
          else
            echo "migrations_changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No database migration changes detected"
          fi
          
          # Check if prisma schema has changes
          if git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E '^backend/prisma/schema.prisma'; then
            echo "schema_changed=true" >> $GITHUB_OUTPUT
            echo "üìã Prisma schema changes detected"
          else
            echo "schema_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine if migrations should run
        id: should_migrate
        run: |
          # Handle both workflow_dispatch and workflow_call contexts
          # workflow_dispatch uses github.event.inputs, workflow_call uses inputs
          MANUAL_OVERRIDE="${{ inputs.run_migrations || github.event.inputs.run_migrations }}"
          MIGRATIONS_CHANGED="${{ steps.migration_check.outputs.migrations_changed }}"
          
          echo "üìã Migration input received: '$MANUAL_OVERRIDE'"
          
          if [ "$MANUAL_OVERRIDE" = "true" ]; then
            echo "run_migrations=true" >> $GITHUB_OUTPUT
            echo "üöÄ Migrations will run (manual override)"
          elif [ "$MANUAL_OVERRIDE" = "false" ]; then
            echo "run_migrations=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è Migrations skipped (manual override)"
          elif [ "$MIGRATIONS_CHANGED" = "true" ]; then
            echo "run_migrations=true" >> $GITHUB_OUTPUT
            echo "üöÄ Migrations will run (changes detected)"
          else
            echo "run_migrations=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è No migrations needed (no changes detected)"
          fi
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ steps.config.outputs.REGION }}

      - name: Determine if seed should run
        id: should_seed
        run: |
          # Handle both workflow_dispatch and workflow_call contexts
          SEED_INPUT="${{ inputs.run_seed || github.event.inputs.run_seed }}"
          echo "üìã Seed input received: '$SEED_INPUT'"
          if [ "$SEED_INPUT" = "true" ]; then
            echo "run_seed=true" >> $GITHUB_OUTPUT
            echo "üå± Seed will run"
          else
            echo "run_seed=false" >> $GITHUB_OUTPUT
          fi

      - name: Install Session Manager plugin
        if: steps.should_migrate.outputs.run_migrations == 'true' || steps.should_seed.outputs.run_seed == 'true'
        run: |
          echo "üì¶ Installing AWS Session Manager plugin..."
          curl -sS "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" -o "session-manager-plugin.deb"
          sudo dpkg -i session-manager-plugin.deb
          session-manager-plugin --version
          echo "‚úÖ Session Manager plugin installed"
          
      - name: Login to ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Build and push Docker image
        env:
          REGISTRY: ${{ steps.ecr.outputs.registry }}
          REPO: ${{ steps.config.outputs.ECR_REPO }}
          TAG: ${{ github.sha }}
        run: |
          echo "üî® Building backend Docker image..."
          cd backend
          docker build -t $REGISTRY/$REPO:$TAG -t $REGISTRY/$REPO:latest -f Dockerfile.prod .
          
          echo "üì§ Pushing to ECR..."
          docker push $REGISTRY/$REPO:$TAG
          docker push $REGISTRY/$REPO:latest
          echo "‚úÖ Image pushed: $REGISTRY/$REPO:$TAG"
          
      - name: Deploy to ECS
        id: deploy
        env:
          CLUSTER: ${{ steps.config.outputs.CLUSTER }}
          SERVICE: ${{ steps.config.outputs.SERVICE }}
          REGISTRY: ${{ steps.ecr.outputs.registry }}
          REPO: ${{ steps.config.outputs.ECR_REPO }}
          TAG: ${{ github.sha }}
        run: |
          echo "üöÄ Deploying to ECS..."
          
          # Get current task definition
          TASK_DEF=$(aws ecs describe-services --cluster $CLUSTER --services $SERVICE --query 'services[0].taskDefinition' --output text)
          TASK_FAMILY=$(echo $TASK_DEF | cut -d'/' -f2 | cut -d':' -f1)
          
          echo "üìã Current task definition: $TASK_DEF"
          echo "üìã Task family: $TASK_FAMILY"
          
          # Get task definition JSON and update image
          aws ecs describe-task-definition --task-definition $TASK_FAMILY --query 'taskDefinition' > task-def.json
          
          # Update image in task definition - find the container by name "backend"
          NEW_IMAGE="$REGISTRY/$REPO:$TAG"
          echo "üîÑ Updating image to: $NEW_IMAGE"
          
          # Update the backend container image using jq (find by name)
          cat task-def.json | jq --arg IMAGE "$NEW_IMAGE" '
            .containerDefinitions = [.containerDefinitions[] | if .name == "backend" then .image = $IMAGE else . end] | 
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ' > new-task-def.json
          
          # Register new task definition
          NEW_TASK_DEF=$(aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "‚úÖ New task definition registered: $NEW_TASK_DEF"
          
          # Update service with new task definition
          aws ecs update-service --cluster $CLUSTER --service $SERVICE --task-definition $NEW_TASK_DEF --force-new-deployment
          
          echo "‚è≥ Waiting for service to stabilize (timeout: 10 minutes)..."
          # Use a more resilient wait with retries
          MAX_ATTEMPTS=20
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "üìä Check $ATTEMPT/$MAX_ATTEMPTS..."
            
            # Check service status
            SERVICE_STATUS=$(aws ecs describe-services --cluster $CLUSTER --services $SERVICE \
              --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Deployments:length(deployments)}' \
              --output json)
            
            RUNNING=$(echo $SERVICE_STATUS | jq -r '.Running')
            DESIRED=$(echo $SERVICE_STATUS | jq -r '.Desired')
            DEPLOYMENTS=$(echo $SERVICE_STATUS | jq -r '.Deployments')
            STATUS=$(echo $SERVICE_STATUS | jq -r '.Status')
            
            echo "   Status: $STATUS, Running: $RUNNING/$DESIRED, Active deployments: $DEPLOYMENTS"
            
            # Success condition: 1 deployment, running equals desired, status is ACTIVE
            if [ "$STATUS" = "ACTIVE" ] && [ "$RUNNING" = "$DESIRED" ] && [ "$DEPLOYMENTS" = "1" ]; then
              echo "‚úÖ Service stabilized successfully!"
              break
            fi
            
            sleep 30
          done
          
          # Don't fail even if timeout - deployment may complete later
          echo "‚úÖ ECS deployment initiated"

      - name: Get running task for migrations
        id: get_task
        if: steps.should_migrate.outputs.run_migrations == 'true' || steps.should_seed.outputs.run_seed == 'true'
        env:
          CLUSTER: ${{ steps.config.outputs.CLUSTER }}
          SERVICE: ${{ steps.config.outputs.SERVICE }}
        run: |
          echo "üîç Waiting for running task..."
          
          # ECS Fargate tasks can take 2-5 minutes to start
          # Retry for up to 5 minutes (15 attempts x 20 seconds)
          MAX_ATTEMPTS=15
          ATTEMPT=0
          TASK_ARN=""
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "üìä Attempt $ATTEMPT/$MAX_ATTEMPTS - Looking for running task..."
            
            TASK_ARN=$(aws ecs list-tasks \
              --cluster $CLUSTER \
              --service-name $SERVICE \
              --desired-status RUNNING \
              --query 'taskArns[0]' \
              --output text)
            
            if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
              # Verify task is actually in RUNNING state (not just PENDING)
              TASK_STATUS=$(aws ecs describe-tasks \
                --cluster $CLUSTER \
                --tasks $TASK_ARN \
                --query 'tasks[0].lastStatus' \
                --output text)
              
              if [ "$TASK_STATUS" = "RUNNING" ]; then
                echo "‚úÖ Found running task: $TASK_ARN"
                echo "task_arn=$TASK_ARN" >> $GITHUB_OUTPUT
                exit 0
              else
                echo "   Task found but status is $TASK_STATUS, waiting..."
              fi
            else
              echo "   No running task found yet, waiting..."
            fi
            
            sleep 20
          done
          
          echo "‚ùå No running task found after $MAX_ATTEMPTS attempts"
          echo ""
          echo "üîç Debugging: Checking all recent tasks..."
          
          # List all tasks (including stopped) for debugging
          echo "All tasks in service:"
          aws ecs list-tasks --cluster $CLUSTER --service-name $SERVICE --query 'taskArns[]' --output text || true
          
          echo ""
          echo "Stopped tasks:"
          aws ecs list-tasks --cluster $CLUSTER --service-name $SERVICE --desired-status STOPPED --query 'taskArns[]' --output text || true
          
          echo ""
          echo "Service events (last 5):"
          aws ecs describe-services --cluster $CLUSTER --services $SERVICE \
            --query 'services[0].events[:5].[createdAt,message]' --output table || true
          
          echo ""
          echo "üí° Check CloudWatch logs for crash details: /ecs/creditxpress/backend"
          exit 1

      - name: Run database migrations
        if: steps.should_migrate.outputs.run_migrations == 'true'
        env:
          CLUSTER: ${{ steps.config.outputs.CLUSTER }}
          TASK_ARN: ${{ steps.get_task.outputs.task_arn }}
        run: |
          echo "üóÑÔ∏è Running database migrations..."
          
          # Check if ECS Exec is enabled on the task
          echo "üîç Checking ECS Exec status on task..."
          EXEC_ENABLED=$(aws ecs describe-tasks \
            --cluster $CLUSTER \
            --tasks $TASK_ARN \
            --query 'tasks[0].enableExecuteCommand' \
            --output text)
          
          if [ "$EXEC_ENABLED" != "True" ]; then
            echo "‚ùå ECS Exec is NOT enabled on this task"
            echo ""
            echo "To fix this, ensure your ECS service has enableExecuteCommand: true"
            echo "and the task role has the required SSM permissions."
            exit 1
          fi
          
          echo "‚úÖ ECS Exec is enabled"
          
          # Wait for SSM agent to be ready (it starts after the container)
          echo "‚è≥ Waiting for SSM agent to initialize..."
          sleep 30
          
          # Retry ECS Exec with backoff - SSM agent may take time to initialize
          MAX_RETRIES=5
          RETRY_DELAY=15
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "üîÑ Attempt $i/$MAX_RETRIES - Running migrations..."
            
            set +e
            MIGRATION_OUTPUT=$(aws ecs execute-command \
              --cluster $CLUSTER \
              --task $TASK_ARN \
              --container backend \
              --interactive \
              --command "npx prisma migrate deploy" 2>&1)
            
            EXIT_CODE=$?
            set -e
            
            echo "$MIGRATION_OUTPUT"
            
            # Check for EOF/session failure - these are retryable
            if echo "$MIGRATION_OUTPUT" | grep -qE "(Cannot perform start session|EOF|TargetNotConnectedException)"; then
              if [ $i -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è Session failed, waiting ${RETRY_DELAY}s before retry..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                continue
              else
                echo ""
                echo "‚ùå Failed to establish ECS Exec session after $MAX_RETRIES attempts"
                echo ""
                echo "Possible causes:"
                echo "1. SSM Agent is not running in the container"
                echo "2. VPC endpoints for SSM are missing (ssm, ssmmessages, ec2messages)"
                echo "3. Task role is missing required SSM permissions"
                echo "4. Security group is blocking outbound HTTPS (443)"
                echo ""
                echo "Debug command:"
                echo "  aws ecs execute-command --cluster $CLUSTER --task $TASK_ARN --container backend --interactive --command '/bin/sh'"
                exit 1
              fi
            fi
            
            # Session worked, check migration result
            if [ $EXIT_CODE -ne 0 ]; then
              echo "‚ùå Migration command failed with exit code $EXIT_CODE"
              exit 1
            fi
            
            # Verify migration actually ran by checking for success patterns
            if echo "$MIGRATION_OUTPUT" | grep -qE "(No pending migrations|migrations applied|Already in sync|database is up to date)"; then
              echo "‚úÖ Database migrations completed successfully"
              exit 0
            else
              echo "‚ö†Ô∏è Migration output unclear, please verify manually"
              echo "‚úÖ Migration command completed"
              exit 0
            fi
          done

      - name: Run database seed
        if: steps.should_seed.outputs.run_seed == 'true'
        env:
          CLUSTER: ${{ steps.config.outputs.CLUSTER }}
          TASK_ARN: ${{ steps.get_task.outputs.task_arn }}
        run: |
          echo "üå± Running database seed..."
          
          MAX_RETRIES=3
          RETRY_DELAY=15
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "üîÑ Attempt $i/$MAX_RETRIES - Running seed..."
            
            set +e
            SEED_OUTPUT=$(aws ecs execute-command \
              --cluster $CLUSTER \
              --task $TASK_ARN \
              --container backend \
              --interactive \
              --command "npx prisma db seed" 2>&1)
            
            EXIT_CODE=$?
            set -e
            
            echo "$SEED_OUTPUT"
            
            # Check for session failure - retryable
            if echo "$SEED_OUTPUT" | grep -qE "(Cannot perform start session|EOF|TargetNotConnectedException)"; then
              if [ $i -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è Session failed, waiting ${RETRY_DELAY}s before retry..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                continue
              else
                echo "‚ùå Failed to establish ECS Exec session for seed after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
            
            if [ $EXIT_CODE -ne 0 ]; then
              echo "‚ùå Seed command failed with exit code $EXIT_CODE"
              exit 1
            fi
            
            echo "‚úÖ Database seed completed successfully"
            exit 0
          done

      - name: Deployment summary
        run: |
          echo "=========================================="
          echo "üìã BACKEND DEPLOYMENT SUMMARY"
          echo "=========================================="
          echo "Client: ${{ steps.config.outputs.CLIENT }}"
          echo "Region: ${{ steps.config.outputs.REGION }}"
          echo "Cluster: ${{ steps.config.outputs.CLUSTER }}"
          echo "Service: ${{ steps.config.outputs.SERVICE }}"
          echo "Image Tag: ${{ github.sha }}"
          echo "Migrations Run: ${{ steps.should_migrate.outputs.run_migrations }}"
          echo "Seed Run: ${{ steps.should_seed.outputs.run_seed }}"
          echo "=========================================="
          echo "‚úÖ Backend deployment complete!"
